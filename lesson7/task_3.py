"""
3. Массив размером 2m + 1, где m – натуральное число, заполнен случайным образом.
Найдите в массиве медиану. Медианой называется элемент ряда, делящий его на
две равные части: в одной находятся элементы, которые не меньше медианы,
в другой – не больше медианы. Задачу можно решить без сортировки исходного
массива. Но если это слишком сложно, то используйте метод сортировки,
который не рассматривался на уроках
"""
import timeit
import random


def median_v1(orig_list):
    """
    Поиск медианы, первая версия
    """
    # рабочий массив, содержащий наш искомый элемент
    work_list = list(orig_list)
    # work_list = [random.randint(-100, 100) for _ in range(2 * M + 1)]
    # длина рабочего массива
    count = len(work_list)
    # если в массиве один элемент - выводим
    if count == 1:
        return work_list[0]

    # индекс середины рабочего массива, в отсортированном массиве содержит
    # искомое число
    item = count // 2
    # а вдруг рабочий массив отсортирован? начинаем проверку с центра массива
    start = work_list[item]

    # начинаем проверку
    while True:
        # сколько элементов меньше центрального
        lower = [i for i in work_list if i < start]
        # сколько больше
        higher = [i for i in work_list if i > start]
        # сколько равных по значению
        equal = [i for i in work_list if i == start]

        # элементов, меньших предполагаемому больше, чем ожидалось
        if item < len(lower):
            # значит наше искомое число в списке меньших по значению
            work_list = lower
            # предполагаем, что искомое значение уже на месте, это и проверим
            start = work_list[item]
        elif item < len(lower) + len(equal):
            # Нам повезло и мы угадали медиану
            return equal[0]
        else:
            # элементов, больших предполагаемому больше, чем ожидалось
            work_list = higher
            # позиция в массиве больших чисел, чтобы элемент занимал правильное
            # место в начальном
            item = item - (len(lower) + len(equal))
            # надеемся, что элемент уже на месте
            start = work_list[item]


def median_v2(orig_list):
    """
    Поиск медианы, первая версия
    """
    # рабочий массив, содержащий наш искомый элемент
    work_list = list(orig_list)
    #work_list = [random.randint(-100, 100) for _ in range(2 * M + 1)]
    # длина рабочего массива
    count = len(work_list)
    # если в массиве один элемент - выводим
    if count == 1:
        return work_list[0]

    # чаще всего медиана или равна, или очень близка к числу, наименнее отличающемуся от
    # среднего по массиву. Попробуем его задать начальным
    average = sum(work_list) / len(work_list)
    # для начала зададим искомое первый эллементов
    med = work_list[0]
    # отклонение от среднего
    min_val = abs(med - average)
    # ищем число с минимальным отклонением от среднего
    for i in work_list:
        dif = abs(i - average)
        if dif < min_val:
            min_val = dif
            med = i
    # индекс середины рабочего массива, в отсортированном массиве содержит
    # искомое число
    item = count // 2
    # предпологаем, что минимально отличающееся от среднего значения и есть
    # искомое
    start = med

    # начинаем проверку
    while True:
        # сколько элементов меньше центрального
        lower = [i for i in work_list if i < start]
        # сколько больше
        higher = [i for i in work_list if i > start]
        # сколько равных по значению
        equal = [i for i in work_list if i == start]

        # элементов, меньших предполагаемому больше, чем ожидалось
        if item < len(lower):
            # значит наше искомое число в списке меньших по значению
            work_list = lower
            # предполагаем, что искомое значение уже на месте, это и проверим
            start = work_list[item]
        elif item < len(lower) + len(equal):
            # Нам повезло и мы угадали медиану
            return equal[0]
        else:
            # элементов, больших предполагаемому больше, чем ожидалось
            work_list = higher
            # позиция в массиве больших чисел, чтобы элемент занимал правильное
            # место в начальном
            item = item - (len(lower) + len(equal))
            # надеемся, что элемент уже на месте
            start = work_list[item]
#----------------------------------------------------------------------------------------------
# генерируем массив
M = 15
ORIG_LIST = [random.randint(-100, 100) for _ in range(2 * M + 1)]
# контроольный вывод сгенерированного массива
print(f'Задан массив: {ORIG_LIST}')
# результат нашей функции
print(f'Медиана массива:      {median_v1(ORIG_LIST)}')
print(f'Медиана массива:      {median_v2(ORIG_LIST)}')
# заведомо правильный ответ, сортируем встроенной функцией и выводим
# центральный
print(f'Контрольное значение: {sorted(ORIG_LIST)[M]}')

print()
print(
    f'Замерим время работы двух вариантов функции. Для точности генерим массив прямо '
    f'внутри функции. Получим среднее время реальной работы')
print("Вариант 1")
print(
    timeit.timeit(
        "median_v1(ORIG_LIST)",
        setup="from __main__ import median_v1, ORIG_LIST",
        number=1000))
print("Вариант 2")
print(
    timeit.timeit(
        "median_v2(ORIG_LIST)",
        setup="from __main__ import median_v2, ORIG_LIST",
        number=1000))
"""
Задан массив: [59, 53, -12, 64, 27, -88, 98, -52, 31, 51, -66, 39, 62, 61, 60, 48, 60, -22,
                88, 45, -63, 44, 23, 68, -25, 91, -97, 52, -79, -50, -28]
Медиана массива:      44
Медиана массива:      44
Контрольное значение: 44

Замерим время работы двух вариантов функции. Для точности генерим массив прямо внутри функции.
Получим среднее время реальной работы
Вариант 1
0.0506369
Вариант 2
0.0489754

Разница не принципиальная
"""
