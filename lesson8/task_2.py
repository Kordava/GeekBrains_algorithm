"""
2. Закодируйте любую строку из трех слов по алгоритму Хаффмана.
"""

"""
Сразу оговоримся, алгоритм Хаффмана не однозначен, он не всегда приводит к построению 
единственно возможного дерева, поскольку на каждом шаге выбор вершин с наименьшим весом 
может быть не единственным. Выбор порядка, в котором будут сливаться две вершины 
(то есть, какая из них будет левым, а какая правым поддеревом) также произволен.

Мы будем выбирать вершины с равным весом слева на право, добавлять новые элементы к 
элементам такого же веса слева. На первом шаге будем сортировать элементы меньшего 
веса по алфавиту.

Данные оговорки позволят получить достаточно повторяемый результат.

И еще, как говорится в философии Pythona (import this) сначала коллекции, если не получается 
функции и модули, если совсем ни как, то классы. Соответственно вариант с классами отбрасываем. 
Все же язык оптимизирован согласно философии.
В данном задании нам не требуется много экземпляров одного класса с разными значениями.

Я извиняюсь, не идет, а сдавать пора. Использовал Ваш код, этот мне кажется самым оптимальным и
самым каноническим. Его и использую. Лучше уже не напишу, а хуже делать мысл? 

Код понятен, коллекция коунтер для подсчета количества каждой из букв, 
потом коллекция очереди для прохода по отсортированному по возрастанию 
каунтеру и отбрасыванию последних использованных элементов. Далее через перечисление проходим наш
список и вставляем новый элемент согласно его "веса" слева от равных элементов. Когда остается
один элемент в списке выходим из цикла. Далее рекурсивно выводим наш вложенный словарь пока не 
дойдем до элемента-символа (не словаря), это сигнал, что мы дошли до листа, выводим код.

Результат:
s = "С праздниками! Спасибо за интересный курс!"
0110 100 0111 1010 1110 0100 00010 1011 1111 0101 1110 00011 1111 11010 100 0110 0111 1110 1100 
1111 00000 00001 100 0100 1110 100 1111 1011 00110 11011 1010 11011 1100 1011 00111 00100 100 
0101 00101 1010 1100 11010 
"""

"""Хаффман через коллекции"""


from collections import Counter, deque


def haffman_tree(s):
    # Считаем уникальные символы.
    # Counter({'e': 4, 'b': 3, 'p': 2, ' ': 2, 'o': 2, 'r': 1, '!': 1})
    count = Counter(s)
    # Сортируем по возрастанию количества повторений.
    # deque([('r', 1), ('!', 1), ('p', 2), (' ', 2), ('o', 2), ('b', 3), ('e', 4)])
    sorted_elements = deque(sorted(count.items(), key=lambda item: item[1]))
    # Проверка, если строка состоит из одного повторяющего символа.
    if len(sorted_elements) != 1:
        # Цикл для построения дерева
        while len(sorted_elements) > 1:
            # далее цикл объединяет два крайних левых элемента
            # Вес объединенного элемента (накопленная частота)
            # веса - 2, 4, 4, 7, 8, 15
            weight = sorted_elements[0][1] + sorted_elements[1][1]
            # Словарь из 2 крайних левых элементов, попутно вырезаем их
            # из "sorted_elements" (из очереди).
            # comb - объединенный элемент
            '''
            {0: 'r', 1: '!'}
            {0: {0: 'r', 1: '!'}, 1: 'p'}
            {0: ' ', 1: 'o'}
            {0: 'b', 1: {0: ' ', 1: 'o'}}
            {0: {0: {0: 'r', 1: '!'}, 1: 'p'}, 1: 'e'}
            {0: {0: 'b', 1: {0: ' ', 1: 'o'}}, 1: {0: {0: {0: 'r', 1: '!'}, 1: 'p'}, 1: 'e'}}
            '''
            comb = {0: sorted_elements.popleft()[0],
                    1: sorted_elements.popleft()[0]}

            # Ищем место для ставки объединенного элемента
            for i, _count in enumerate(sorted_elements):
                if weight > _count[1]:
                    continue
                else:
                    # Вставляем объединенный элемент
                    sorted_elements.insert(i, (comb, weight))
                    break
            else:
                # Добавляем объединенный корневой элемент после
                # завершения работы цикла

                sorted_elements.append((comb, weight))
            '''
            deque([({0: 'r', 1: '!'}, 2), ('p', 2), (' ', 2), ('o', 2), ('b', 3), ('e', 4)])
            deque([(' ', 2), ('o', 2), ('b', 3), ({0: {0: 'r', 1: '!'}, 1: 'p'}, 4), ('e', 4)])
            deque([('b', 3), ({0: ' ', 1: 'o'}, 4), ({0: {0: 'r', 1: '!'}, 1: 'p'}, 4), ('e', 4)])
            deque([({0: {0: 'r', 1: '!'}, 1: 'p'}, 4), ('e', 4), ({0: 'b', 1: {0: ' ', 1: 'o'}}, 7)])
            deque([({0: 'b', 1: {0: ' ', 1: 'o'}}, 7), ({0: {0: {0: 'r', 1: '!'}, 1: 'p'}, 1: 'e'}, 8)])
            deque([({0: {0: 'b', 1: {0: ' ', 1: 'o'}}, 1: {0: {0: {0: 'r', 1: '!'}, 1: 'p'}, 1: 'e'}}, 15)])
            '''
    else:
        # приравниваемыем значение 0 к одному повторяющемуся символу
        weight = sorted_elements[0][1]
        comb = {0: sorted_elements.popleft()[0], 1: None}
        sorted_elements.append((comb, weight))
    # sorted_elements - deque([({0: {0: 'b', 1: {0: ' ', 1: 'o'}}, 1: {0: {0: {0: 'r', 1: '!'}, 1: 'p'}, 1: 'e'}}, 15)])
    # {0: {0: 'b', 1: {0: ' ', 1: 'o'}}, 1: {0: {0: {0: 'r', 1: '!'}, 1: 'p'}, 1: 'e'}}
    # словарь - дерево
    return sorted_elements[0][0]


code_table = dict()

# tree - {0: {0: 'b', 1: {0: ' ', 1: 'o'}}, 1: {0: {0: {0: 'r', 1: '!'}, 1: 'p'}, 1: 'e'}}
def haffman_code(tree, path=''):
    # Если элемент не словарь, значит мы достигли самого символа
    # и заносим его, а так же его код в словарь (кодовую таблицу).
    if not isinstance(tree, dict):
        code_table[tree] = path
    # Если элемент словарь, рекурсивно спускаемся вниз
    # по первому и второму значению (левая и правая ветви).
    else:
        haffman_code(tree[0], path=f'{path}0')
        haffman_code(tree[1], path=f'{path}1')


# строка для кодирования
s = "С праздниками! Спасибо за интересный курс!"

# функция заполняет кодовую таблицу (символ-его код)
# {'b': '00', ' ': '010', 'o': '011', 'r': '1000', '!': '1001', 'p': '101', 'e': '11'}
haffman_code(haffman_tree(s))

# code_table - {'b': '00', ' ': '010', 'o': '011', 'r': '1000', '!': '1001', 'p': '101', 'e': '11'}

# выводим коды для каждого символа
for i in s:
    print(code_table[i], end=' ')
print()