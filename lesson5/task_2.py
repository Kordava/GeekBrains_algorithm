"""
2.	Написать программу сложения и умножения двух шестнадцатеричных чисел.
При этом каждое число представляется как массив, элементы которого это цифры числа.
Например, пользователь ввёл A2 и C4F. Сохранить их как [‘A’, ‘2’] и [‘C’, ‘4’, ‘F’] соответственно.
Сумма чисел из примера: [‘C’, ‘F’, ‘1’], произведение - [‘7’, ‘C’, ‘9’, ‘F’, ‘E’].

Подсказка:
Для решения задачи обязательно примените какую-нибудь коллекцию из модуля collections
Для лучшее освоения материала можете даже сделать несколько решений этого задания,
применив несколько коллекций из модуля collections
Также попробуйте решить задачу вообще без collections и применить только ваши знания по ООП
(в частности по перегрузке методов)
"""
# ВАРИАНТ 1. ПРОСТО РАЗОБРАТЬСЯ-------------------------------------------


def very_simple(num_1, num_2):
    """
    самый простой вариант со встроенной функцией
    для проверки дальнейших расчетов
    """
    sum_simple = hex(int(num_1, 16) + int(num_2, 16))
    mult_simple = hex(int(num_1, 16) * int(num_2, 16))
    return sum_simple, mult_simple


def sum_hex(num_1, num_2):
    """
    СУММА ЧИСЕЛ В 16-ТИРИЧНОЙ СИСТЕМЕ
    """
    # тут сохраним итог
    total = []
    # числа суммируются начиная с низших разрядов (последних элементов строки), для удобства
    # дальнейшей работы создадим из чисел списки и перевернем их наоборот 'C4F' -> 'F4C'.
    # переворот через NUM_2[::-1]
    num_1, num_2 = list(num_1[::-1]), list(num_2[::-1])
    # Cоздаём список из элементов 16-тиричной системы '0123456789ABCDEF'
    list_of_numbers = [str(i) for i in range(10)] + \
        ['A', 'B', 'C', 'D', 'E', 'F']

    # Создаём вспомагательные переменные и запускаем цикл по элементам более длинного числа.
    # Находим индексы соответствующих элементов первого и второго числа в созданном ранее
    # списке символов 16-ричной системы. Если у нас встретится переход в другой разряд,
    # то присваиваем K = 1, если нет, то K = 0.
    # индекс элементов более короткого числа
    j = 0
    k = 0
    if len(num_1) > len(num_2):
        num_1, num_2 = num_2, num_1
    for i in num_2:
        # получаем из списка символов 16-ричной системы индекс нашей "цифры"
        # для обоих из чисел
        one = list_of_numbers.index(i)
        # если первое число закончилось, то ее отсутсвующие элементы дополняем
        # нулями
        if j >= len(num_1):
            two = 0
        else:
            two = list_of_numbers.index(num_1[j])
        # Суммируем индексы и берем остаток от их деления на 16.
        # Это будет индекс итоговой "цифры" суммы в списке элементов
        # 16-тиричной системы '0123456789ABCDEF'
        res = one + two + k
        total.append(list_of_numbers[res % 16])
        # Если был переход разрядов, то следующая стока сохранит 1, если
        # переходов не было 0
        k = res // 16
        # индекс следующего элемента меньшего числа
        j += 1
    # при выводе разворачиваем сумму обратно
    return total[::-1]


def mult_hex(num_1, num_2):
    """
    ПРОИЗВЕДЕНИЕ ЧИСЕЛ В 16-ТИРИЧНОЙ СИСТЕМЕ

    Тестовый пошаговый пример
    -----------------------------------------
    Разр.	c	7	6	5	4	3	2	1	0
                                    8	1
    A					    			a	2
    B				    	7	c	9	f	e
                          -----------------
    a2 x e				    		8	d	c
    a2 x f				    	9	7	e
                         -----------------
    8dc + 97e0				    a	0	b	c
    a2 x 9				    5	b	2
                          -----------------
    a0bc + 5b200		    6	5	2	b	c
    a2 x c			     7	9	8
                         -------------------
    652bc + 798000	    7	f	d	2	b	c
    a2 x 7		    4	6	e
                    -------------------------
    7fd2bc +
    + 46e0000       4	e	d	d	2	b	c
    """
    # числа умножаются начиная с низших разрядов (последних элементов строки), для удобства
    # дальнейшей работы создадим из чисел списки и перевернем их наоборот 'C4F' -> 'F4C'.
    # переворот через my_list[::-1]
    num_1, num_2 = list(num_1[::-1]), list(num_2[::-1])
    # Cоздаём список из элементов 16-тиричной системы '0123456789ABCDEF'
    list_of_numbers = [str(i) for i in range(10)] + \
        ['A', 'B', 'C', 'D', 'E', 'F']
    # Создаём вспомагательные переменные и запускаем цикл по элементам более длинного числа.
    # Находим индексы соответствующих элементов первого и второго числа в созданном ранее
    # списке символов 16-тиричной системы. Если у нас встретится переход в другой разряд,
    # то присваиваем количество переходов разряда переменной k, если нет, то k
    # = 0.
    k = 0
    # сохраняет промежуточный результат умножения
    mult = []
    # сохраняет количество 0 (разрядов), которые добавляются к результату
    # умножения
    zero = []
    # будет содержать результат
    sum_tmp = []
    # каждый элемент более длинного числа умножаем на короткое
    for i in num_2:
        # получаем из списка символов 16-ричной системы индекс нашей "цифры"
        # для обоих из чисел
        one = list_of_numbers.index(i)
        # если первое число закончилось, то ее отсутсвующие элементы дополняем
        # единицами
        for j in num_1:
            two = list_of_numbers.index(j)
        # Суммируем индексы и берем остаток от деления на 16. Это будет индекс
        # итоговой "цифры" суммы
            res = one * two + k
            mult.append(list_of_numbers[res % 16])
        # Если был переход разрядов, то следующая стока сохранит количество переходов или 0,
        # если перходов не было
            k = res // 16
        # если остался переход разряда в последней операции необходимо его
        # добавить в начало числа
        if k > 0:
            mult.append(list_of_numbers[k])
            # обнуляем счетчик
            k = 0
        # если это самое первое действие, то у нас только одно слагаемое, сумма будет равна ему
        # для первого элемента нулей справа не будет, поэтому zero = []
        if zero == []:
            sum_tmp = mult[::-1]
        else:
            # иначе добавляем новому слагаемому нули справа для выравнивания
            # разрядов
            mult = zero + mult
            # суммируем множители
            sum_tmp = sum_hex(mult[::-1], sum_tmp)
        # увеличиваем счетчик разрядов (количество 0)
        zero += ['0']
        # обнуляем список последнего множителя
        mult = []
    return sum_tmp
# -----------------------------------------------------------------------------------------------
# Рабочая область


# сохраняем наши числа в переменых
NUM_1 = 'A2'
NUM_2 = 'C4F'

# выведем результаты контрольного расчета
print(very_simple(NUM_1, NUM_2))

# и результаты наших функции
print(sum_hex(NUM_1, NUM_2))
print(mult_hex(NUM_1, NUM_2))

# Результаты выполнения
    # ('0xcf1', '0x7c9fe')
    # ['C', 'F', '1']
    # ['7', 'C', '9', 'F', 'E']
# Совпадает
