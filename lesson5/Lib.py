# функция контроля выхода
def check_out():                       # n - переменная контроля выхода из программы
    """Позволяет организовать непрерывный ввод данных пользователем

    Пользователь может постоянно вводить новые данные и получать результат программы.
    При вводе символа 'q' функция завершает программу

        # пример оформления кода прграммы
        def main():
            var_1 = input('var_1: ')            # пользователь вводит что угодно
            var_2 = input('var_2: ')
            var_3 = input("var_3: ")
            my_func(var_1, var_2, var_3)        # запускаем нашу функцию
            check_out()                        # в конце основного кода вызовется функция для контроля повторного исполнения

        # ЭТО СОБСТВЕННО ВЫЗОВ КОДА ПРОГРАММЫ
        main()                                  # ну, вперед!

    """
    str = input(f'Для выхода из программы нажмите "1", для продолжения просто "Enter"')
    # если n не равно символу 'q', то снова вызываем главную программу main()
    return main() if str != 'q' else None

# функция контроля ввода строки с заданными условиями


def input_str(text, str_type):
    """Проверяет, что пользователь ввел число с заданным условием.

        Именованные параметры:
        nbr_type        -- условие на строку
        nbr_text        -- надпись, выводимая в запросе на ввод числа для пользователя

        nbr_type. Передает уловие отбора строки при помощи функции lambda.
        Если условие не передается, то передаем функцию следующего вида (lambda a: True)

        Пример вызова функции:
        1.
        text = '> Введите название: '
        print(input_str(text, lambda a: True)      - условий нет

        2.
        text = '> Введите символ: '
        print(input_str(text, lambda a: a = 'a'))  - ввод символа 'a'

    """
    while True:  #цикл закончится тогда, когда введенное значение будет строкой с заданным условием
        value = input(f"{text}")    # пользователь вводит строку
        if str_type(value):  # условие передается функцией вида lambda a: a > 0
            return value
        print(f"'Ошибка' {text}")
# Определения используемых фукций конец //////////////////////////////////

# функция контроля ввода числа с заданными условиями


def input_nbr(nbr_type, nbr_text, nbr_cond):
    """Проверяет, что пользователь ввел число с заданным условием.

        Именованные параметры:
        nbr_type        -- тип числа (int или float)
        nbr_text        -- надпись, выводимая в запросе на ввод числа для пользователя
        nbr_cond        -- условие, налагаемое на число

        nbr_type. Если парамент принимает значение 'int', то получаем целое число.
        Любое другое значение выведет число с плавающей точкой

        nbr_cond. Передает уловие отбора чисел при помощи функции lambda.
        Если условие не передается, то передаем функцию следующего вида (lambda a: True)

        Пример вызова функции:
        1.
        text = '> Введите действительное положительное число x: '
        print(input_nbr('int',text,lambda a: True)      - ввод целого числа, условий нет

        2.
        text = '> Введите действительное положительное число x: '
        print(input_nbr('int', text, lambda a: a > 0))  - ввод целого числа, число больше нуля

        3.
        Обратите внимание на два момента. Первое - мы проверяем возникновение двух различных
        исключений: TypeError и ValueError. Таким образом мы не только обработаем ввод числа
        с плавающей точкой (например: '9.9'), но и обработаем пустой ввод и даже ввод
        произвольной строки, например: 'Ham on rye'. Второе -- мы точно указали какие исключения
        собираемся отлавливать. В принципе, можно оставить оператор exception без аргументов,
        особо не обременяя себя указанием названий интересующих нас исключений
    """
    value = input(f"{nbr_text}")  # пользователь вводит число
    while True:  # цикл закончится тогда, когда введенное значение будет числом с заданным условием
        # если введенное значение не число или не удовлетворяет условиям
        try:
            # пытаемся преобразовать переменную в целое число
            float(value)
            # если успешно, проверим, заданное условие
            if nbr_cond(
                    float(value)):  # условие передается функцией вида lambda a: a > 0
                break  # Если ввод правильный, выходим
            # пользователь повторно вводит число
            value = input(f"'Ошибка' {nbr_text}")
        except (TypeError, ValueError):  # обработаем Перехват исключения
            # если введенное значение нельзя преобразовать в число
            # flag = False
            value = input(f"'Ошибка' {nbr_text}")
    # Если ввод верный, то возвращаем значение целым или с плавающей точкой.
    # В зависимости от запроса
    return int(float(value)) if nbr_type == 'int' else float(value)


def is_number(value):
    """Проверяет, является ли строка числом, удовлетворяющее заданным условиям

        Именованные параметры:
        nbr_type        -- тип числа (int или float)
        nbr_cond        -- условие, налагаемое на число

        value. переданное значение для проверки

        Если число, вернем True, иначе False

        Пример вызова функции:
        is_number(value)
    """
    try:
        # пытаемся преобразовать переменную в целое число
        float(value)
        return True                         # True, если число
    except ValueError:                      # обработаем Перехват исключения
        # если введенное значение нельзя преобразовать в число то возвращаем
        # False
        return False

def my_timeit(statements, mode=0):
    """
    Необходима библиотека import timeit

    Функция рассчитывает время исполнения алгоритма.
    Ключевое предположение, что прошлые запуски алгоритма не влияют на последующие, иначе функция
    будет работать некорректно. Например, если вы измеряете скорость выполнения mylist.sort().

    В функцию передается:
       1. statements - перечень функций с параметрами в виде списка. Например:
            а) statements = ['some_slow_method(5)',
                  'some_slow_method(3)',
                  'some_quick_method(5)',
                  'some_quick_method(3)']
            б) N=str(5)
               M=str(3)
               statements = ['some_slow_method(' + N + ')',
                  'some_slow_method(' + M + ')',
                  'some_quick_method(' + N + ')',
                  'some_quick_method(' + M + ')']
       2. mode - режим вывода:
            0 - вывод на экран
            1 - вывод в словарь


    """
    # проверка режима вывода

    # вывод на экран
    if mode == 0:
        # перебираем все функции из списка
        for item in statements:
            # в парметре setup метода timeit нужно название функции без скобок
            # (т.е. ссылка на функцию)
            setup = "from __main__ import " + item[: item.find("(")]
            # выводим результат текущей функции
            print(
                f'{item} выполняется за '
                f'{min(timeit.repeat(item, setup, timeit.default_timer, 3, 1))} секунд(ы)')
        ret = None
    # вывод в словарь
    elif mode == 1:
        # создаем словарь
        memory = {}
        # перебираем все функции из списка
        for item in statements:
            # в парметре setup метода timeit нужно название функции без скобок
            # (т.е. ссылка на функцию)
            setup = "from __main__ import " + item[: item.find("(")]
            # сохраняем результат в словарь
            memory[item] = min(
                timeit.repeat(
                    item,
                    setup,
                    timeit.default_timer,
                    3,
                    1))
        ret = memory
    else:
        print(f"Режим работы может быть:\n    0 - вывод на экран\n    1 - вывод в словарь")
        ret = None
    return ret
# --------------------------------------------------------------------------------------------------


def o_notation(func_start, func_end, iter_start, iter_end):
    """
    Необходима библиотека import math

    Функция определяет примерный тип сложности алгоритма.

    func_start - строка, содержащая вызов функции с начальными входными параметрами
    func_end - строка, содержащая вызов функции с конечными входными параметрами
    iter_start - начальное значение итерируемого аргумента функции
    iter_end - конечное значение итерируемого аргумента функции


    Примеры вызова функции:
        1) o_notation('some_quick_method(5)', 'some_quick_method(10)', 5, 10)
        2) N=5
           M=10
           func_start =  'some_quick_method(arg_1, arg_2, ..., arg_k, ' + str(N) + ')'
           func_end =  'some_quick_method(arg_1, arg_2, ..., arg_k, ' + str(M) + ')'
           o_notation(func_start, func_end, n, m)

    Используются типовые порядки роста сложности алгоритма:
        1. O(1)         - константная сложность
        2. O(log n)     – логарифмическая сложность
        3. O(n)         – линейная сложность
        4. O(n*log n)   - линеарифметическая сложность
        5. O(n**2)      – квадратичная сложность
        6. O(n**3)      – кубическая сложность
        7. O(e**n)      – экспоненциальная сложность

    Примерный тип сложности определяется исходя из времени выполнения алгоритма на разных
    входных данных. Полученные данные времени выполнения сверяются с графиками типовых порядков
    роста и выбирается самый ближний. Подразумевается, что алгоритм непрерывен.
    Начальная точка всех графиков считается (0,0).

    В литературе написано, что одна программа не может оценить сложность другой, так как они
    работают в одной среде. По моим прикидкам это верно лишь в том случае, если мы работаем в
    линейной системе координат (время, данные). А вот если мы попадем в систему координат,
    где шкала входных данных не линейна, а соответствует функции сложности алгоритма, то
    результаты работы нашей функции лягут близко к прямой линии, а влияние остальных фаторов
    распытится и при усреднеии нивелируется. Т.е. мы берем нашу функцию "под лупу".

    Если в системе координат шкалу оси x (итерируемый параметр) брать в соостветствии с функцией
    порядка роста сложности алгоритма (например 1, log(n), n ...), то результаты
    замеров времени данного алгоритма на разных входных данных должны быть очень близки к
    прямой линии. Соответсвенно, по первому времени выполнения рассчитываем угловой коэффициент
    прямой из начала координат и экстраполируем по этому расчету ожидаемое время выполнения
    алгоритма для второго значения итерируемого аргумента. Для той системы координат, для которой
    расчетное время будет ближе всего к фактическому, к той функции и стремится сложность алгоритма.

    Данный метод имеет право на жизнь, т.к. прямой метод ручного расчета сложности алгоритма также
    дает лишь оценочную функцию. Расчет верен, например только до тех пор, пока операцию
    сложения можно считать атомарной. На больших числах, которыми процессор не может оперировать
    непосредственно (например, загрузить в регистры и выполнить инструкцию add), суммирование
    не является атомарной операцией и начинает зависеть от количества разрядов в числе.
    А оно зависит от n – в результате алгоритм имеет более высокую, чем расчетная,
    вычислительную сложность на больших n. Не зная тоно характеристики компьютера может оказаться,
    что точнее оценить тип сложности алгоритма проще программно по типовым шаблонам.

    """

    # создаем словарь, в котором будут содержаться данные угловых коэффициентов прямых
    # функций порядка роста в соответствующих системах координат
    memory = {
        'O(1)': 0,
        'O(log n)': 0,
        'O(n)': 0,
        'O(n*log n)': 0,
        'O(n**2)': 0,
        'O(n**3)': 0,
        'O(e**n)': 0
    }

    # вызываем функцию измерения времени работы алгоритма my_timeit() в режиме
    # вывода результатов в словарь

    # импортируем данные вызова в специальную переменную
    statements = [func_start,
                  func_end]
    # вызываем функцию и сохраняем результат в переменную res
    res = my_timeit(statements, 1)

    # полученные результаты замеров сохраняем из словаря res в переменные,
    # исключительно для удобства читаемости кода
    time_1 = res[func_start]
    time_2 = res[func_end]

    # считаем угловые коэффициенты прямых между точками (0,0)->(f(iter_start), time_1) и
    # рассчитываем ожидаемое значение времени в точке f(iter_end) в системах координат,
    # где шкала оси x соответствует каждой из функций потенциальных порядков роста
    # сложности алгоритма.
    # Сохраняем модуль разницы фактического time_2 и расчетного time_2 в словаре memory
    # в ключе соответствующего названия.
    # начальная точка (0,0), значит коэффициент равен t/f(x), расчетное time_2'=t/f(x)*f(x2),
    # а их разница: time_2-time_2'.
    # x1 - iter_start; x2 - iter_end
    # time_1 - res[func_start]; time_2 - res[func_end]
    memory['O(1)'] = abs(time_1 - time_2)
    memory['O(log n)'] = abs(
        time_2 -
        time_1 /
        math.log2(
            iter_start) *
        math.log2(
            iter_end))
    memory['O(n)'] = abs(time_2 - time_1 / iter_start * iter_end)
    memory['O(n*log n)'] = abs(time_2 - time_1 / (math.log2(iter_start)
                                                  * iter_start) * (math.log2(iter_end)
                                                                   * iter_end))
    memory['O(n**2)'] = abs(time_2 - time_1 / (iter_start**2) * (iter_end**2))
    memory['O(n**3)'] = abs(time_2 - time_1 / (iter_start**3) * (iter_end**3))
    try:
        memory['O(e**n)'] = abs(time_2 - time_1 /
                            math.exp(iter_start) * math.exp(iter_end))
    except:
        # заполняем большим значением
        memory['O(e**n)'] = 10000
        print (f"O(e**n) не оценено, слишком большие данные")

    # min(memory, key=memory.get) выдает ключ минимального значения словаря, но используем цикл
    # причину смотрим в task_1_3.py
    # print(
    #    f"Порядок роста сложности алгоритма {func_start[: func_start.find('(')]}: "
    #    f"{min(memory, key=memory.get)}")
    min_key = 'O(1)'
    min_val = memory[min_key]
    for key, val in memory.items():
        if val < min_val:
            min_val = val
            min_key = key
    print(
        f"Порядок роста сложности алгоритма {func_start[: func_start.find('(')]}: "
        f"{min_key}")

# --------------------------------------------------------------------------------------------------

