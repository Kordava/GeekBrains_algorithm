"""
Написать два алгоритма нахождения i-го по счёту простого числа.
Без использования «Решета Эратосфена»;
Используя алгоритм «Решето Эратосфена»

Подсказка:
Сравните алгоритмы по времени на разных порядковых номерах чисел:
10, 100, 1000
Опишите результаты, сделайте выводы, где и какой алгоритм эффективнее
Подумайте и по возможности определите сложность каждого алгоритма

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
"""
#import time
#import timeit
import math
# импортируем функцию замера времени работы из первого задания
from lib import my_timeit
from lib import o_notation

# рабочая область----------------------------------------------------------------------------------

# Блок 1. Решение без "Решета"--------------------------------------------


def issimple_old(numb):
    """функция проверяет, является ли число простым.
    Первая версия, без доработок"""
    # проверяем чмсла от 2 до указанного числа
    for i in range(2, numb):
        # если остаток от деления равен нулю
        if numb % i == 0:
            # значит делится нацело и число не простое
            return False
    # иначе простое
    return True


def issimple(numb):
    """функция проверяет, является ли число простым
    Доработанная версия"""

    # 1. Переберать надо числа, не превосходящие корня из искомого, так как
    # максимальный из меньших множителей — это пара с равными множителями у = х * х
    # в других случаях один из множителей меньше х. А нам достаточно наличие
    # одного
    numb_range = math.ceil(math.sqrt(numb) + 1)
    # 2. все числа, которые оканчиваются на 5 не простые. Сразу отсеиваем их
    # отсеиваем
    if numb > 5 and numb % 10 == 5:
        return False
    # проверяем чмсла от 2 до корня квадратного от числа
    for i in range(2, numb_range):
        # если остаток от деления равен нулю
        if numb % i == 0:
            # значит делится нацело и число не простое
            return False
        # иначе простое
    return True


# -------------------------------------------------------------------------------------------------


def simple_old(count):
    """
    Основной код поиска

    """
    # первые два числа нам известны, сразу зададим
    numb = 5
    smpl_list = [2, 3]
    # если спрашивают первые два простых числа, то сразу выводим
    if count == 1:
        return smpl_list[0]
    if count == 2:
        return smpl_list[1]
    # проверяем является ли число простым, если да, то добавляем его в список
    # потом проверяем количество элементов в списке
    # наверное, чуть быстрее счетчиком, но тут за сравнимое время имеем еще и таблицу с данными
    # поэтому оставлю так, в данном случае все же скорость не так пострадает
    while True:
        # если простое
        if issimple_old(numb) is True:
            # добавили в список
            smpl_list += [numb]
        # если то самое, выходим
        if len(smpl_list) == count:
            break
       # если не нашли, идем дальше
        numb += 1
    # выводим найденное число
    return smpl_list[-1]


def simple(count):
    """
    Основной код поиска
    Улучшенная версия

    """
    # первые два числа нам известны, сразу зададим
    numb = 5
    # 1. вместо списка - счетчик
    smpl_count = 2
    # если спрашивают первые два простых числа, то сразу выводим
    if count == 1:
        return 2
    if count == 2:
        return 3
    # проверяем является ли число простым, если да, то добавляем его в список
    # потом проверяем количество элементов в списке
    # наверное, чуть быстрее счетчиком, но тут за сравнимое время имеем еще и таблицу с данными
    # поэтому оставлю так, в данном случае все же скорость не так пострадает
    while True:
        # если простое
        if issimple(numb) is True:
            # добавили в список
            smpl_count += 1
        # если то самое, выходим
        if smpl_count == count:
            break
        # если не нашли, идем дальше
        # 1. шаг чисел - 2. Исключаем четные числа
        numb += 2
    # выводим найденное число
    return numb


# ------------------------------------------------------------------------------------------------

# вперед

# порядковый номер искомого простого числа
I = 10000000
"""
print(f"simple_old для {I}: {simple_old(I)}")
print(f"simple для {I}: {simple(I)}")

# импортируем данные вызова в специальную переменную
STATEMENTS = ['simple_old(' + str(I) + ')',
              'simple(' + str(I) + ')']
# вызываем функцию расчета времени выполнения
my_timeit(STATEMENTS)

# оценим тип сложности алгоритмов
N = 10
M = 1000
START = 'simple_old(' + str(N) + ')'
END = 'simple_old(' + str(M) + ')'
o_notation(START, END, N, M)

START = 'simple(' + str(N) + ')'
END = 'simple(' + str(M) + ')'
o_notation(START, END, N, M)
"""
# импортируем данные вызова в специальную переменную
STATEMENTS = ['simple(' + str(I) + ')']
# вызываем функцию расчета времени выполнения
my_timeit(STATEMENTS)
"""
# оценим тип сложности алгоритмов
N = 100
M = 100000

START = 'simple(' + str(N) + ')'
END = 'simple(' + str(M) + ')'
o_notation(START, END, N, M)
"""
# результаты
#    simple_old для 3000: 27449
#    simple для 3000: 27449
#    simple_old(3000) выполняется за 2.5375297999999997 секунд(ы)
#    simple(3000) выполняется за 0.0284361999999998 секунд(ы)
#    O(e**n) не оценено, слишком большие данные
#    Порядок роста сложности алгоритма simple_old: O(n**2)
#    O(e**n) не оценено, слишком большие данные
#    Порядок роста сложности алгоритма simple: O(n*log n)
# Process finished with exit code 0

# Вывод: оптимизация ускорила функцию на порядки и изменила порядок сложности с n**2 На n*log(n)

# Небольшой комментарий.
# По сути в алгоритме два вложенных цикла, что и показывает n**2 начального алгоритма,
# но уменьшение диапазона поиска до корня квадратного от числа и
# игнорирование половины чисел за счет работы только с нечетными, дало нам поведение log(n)
# для второго цикла. Поведение очень близко к log(n), хотя, если считать руками, то получим что-то
# вроде const*n*sqrt(n)+const. Но это неверно, что показывает ошибка библиотеки math при работе с
# экспонентой. Числа могут быть очень большие и функция поведения усложнится на порядок n и придем
# логарифму
