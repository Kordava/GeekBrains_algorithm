"""
Написать два алгоритма нахождения i-го по счёту простого числа.
Без использования «Решета Эратосфена»;
Используя алгоритм «Решето Эратосфена»

Подсказка:
Сравните алгоритмы по времени на разных порядковых номерах чисел:
10, 100, 1000
Опишите результаты, сделайте выводы, где и какой алгоритм эффективнее
Подумайте и по возможности определите сложность каждого алгоритма

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
"""
#import time
#import timeit
import math

# порядковый номер искомого простого числа
I = 1000

# 1. Без Решета-----------------------------------------------------------------------------------
def issimple(numb):
    """функция проверяет, является ли число простым
    Доработанная версия"""

    # 1. Переберать надо числа, не превосходящие корня из искомого, так как
    # максимальный из меньших множителей — это пара с равными множителями у = х * х
    # в других случаях один из множителей меньше х. А нам достаточно наличие
    # одного
    numb_range = math.ceil(math.sqrt(numb) + 1)
    # 2. все числа, которые оканчиваются на 5 не простые. Сразу отсеиваем их
    # отсеиваем
    if numb > 5 and numb % 10 == 5:
        return False
    # проверяем чмсла от 2 до корня квадратного от числа
    for i in range(2, numb_range):
        # если остаток от деления равен нулю
        if numb % i == 0:
            # значит делится нацело и число не простое
            return False
        # иначе простое
    return True

def simple(count):
    """
    Основной код поиска
    Улучшенная версия

    """
    # первые два числа нам известны, сразу зададим
    numb = 5
    # 1. вместо списка - счетчик
    smpl_count = 2
    # если спрашивают первые два простых числа, то сразу выводим
    if count == 1:
        return 2
    if count == 2:
        return 3
    # проверяем является ли число простым, если да, то добавляем его в список
    # потом проверяем количество элементов в списке
    # наверное, чуть быстрее счетчиком, но тут за сравнимое время имеем еще и таблицу с данными
    # поэтому оставлю так, в данном случае все же скорость не так пострадает
    while True:
        # если простое
        if issimple(numb) is True:
            # добавили в список
            smpl_count += 1
        # если то самое, выходим
        if smpl_count == count:
            break
        # если не нашли, идем дальше
        # 1. шаг чисел - 2. Исключаем четные числа
        numb += 2
    # выводим найденное число
    return numb


# ------------------------------------------------------------------------------------------------
simple(I)
# 2. С решетом------------------------------------------------------------------------------------
def ert(iter1):
    """
    Реализация алгоритма
    Решето Эратосфена

    Конечная версия.

    Основная проблема - алгоритм работает на заданном множисте. А его мы не имеем,
    нет правой границы диапазона. Значит придется иетрировать.

    iter - порядковый номер простого числа, которое требуется найти (входной параметр)
    """
    # мы не знаем, сколько простых чисел в каком диапазоне,
    # но можем оценить. Половина четных чисел отпадает сразу, втрое простое число - 3. В сотне его
    # 33 штуки, за минусом половины четным грубо имеем 15. То, есть 65 чисел из 100 точно
    # не простые. Чуть меньше третьей части. Возьмем коэффициент 2, итерация все равно придет к
    # нужному числу. Плюс придется делать меньше лишних обнулений правой
    # границы.
    num = iter1 * 2
    # счетчик простых чисел
    count = 0
    # счетчик чисел диапазона
    i = 0
    # ряд натуральных чисел до заданного
    my_list = list(range(num + 1))
    # без этой строки итоговый список будет содержать единицу
    my_list[1] = 0
    # будем итерерировать пока не найдем заданное число
    while True:
        # переходим к следующему числу
        i += 1
        # для 1 значение уже ввели
        if i > 1:
            # если достигли границы диапазона, но нужное число не нашли
            if i > num:
                # обнуляем счетчик ряда
                i = 0
                # расширяем диапазон поиска в два раза
                num *= 2
                # заново формируем массив чисел
                my_list = list(range(num + 1))
                # обнуляем счетчик простых чисел
                count = 0
                # переходим на следующую итерацию цикла с новыми значениями
                continue
            # 1. Улучшение. Если значение этого элемента нашего массива равно нулю,
            # значит оно было кратно одному из предыдущих членов массива и уже обнулилось.
            # Поэтому и все остальные элементы кратные это му числу уже заведомо обнулены.
            # Прерываемся и перходим к следующему
            if my_list[i] == 0:
                continue
            # Вот тут важный момент! В этой области могут быть уже только простые числа i.
            # Сложные уже отсеялись на прошлом шаге и обнулены. Тут мы имеем дело с очередным
            # простым числом и будем удалять вправо кратные ему числа. Слева от него или нули, или
            # простые. Поэтому увеличиваем счетчик простых чисел
            count += 1
            # если нужное нам число, возвращаем его и выходим
            if count == iter1:
                return i
            # если до нужного еще не дошли, то убираем заведомо составные числа из правого
            # края массива. Идем по ряду с шагом i (кратным нашему числу),
            # тем самым обнуляя все элементы, кратные i.
            #
            # 2. улучшение - начинаем с элемента i в квадрате,
            # так как идем по возрастанию и остальные элементы обнулены от
            # предыдущих чисел.

            for j in range(i ** 2, num, i):
                my_list[j] = 0
# ------------------------------------------------------------------------------------------------
print(ert(I))
# ------------------------------------------------------------------------------------------------
