"""
1.	Подсчитать, сколько было выделено памяти под переменные в ранее
разработанных программах в рамках первых трех уроков.
Проанализировать результат и определить программы с
наиболее эффективным использованием памяти.
Примечание: Для анализа возьмите любые 1-3 ваших программы или несколько
вариантов кода для одной и той же задачи.
Результаты анализа вставьте в виде комментариев к коду.
Также укажите в комментариях версию Python и разрядность вашей ОС.


ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
"""
# импортируем функцию замера времени работы из первого задания
import time
import memory_profiler
# ------------------------------------------------------------------------------------------------
# 1. Первый шаг улучшения - алгометрический. Уменьшим наш массив за счет четных чисел.
# Исключим их шагом итератора 2

# 2. Результаты.
# Было
# Выполнение заняло 12.53125 сек и 635.1796875 Мб
# ert для 1000000: 15485863

# Стало
# Выполнение заняло 8.921875 сек и 325.96484375 Мб
# ert для 1000000: 15485863

# Итог: число совпало. Памяти в два раза меньше, скорость в полтора раза выше


# @profile
def ert(iter1):
    """
    Реализация алгоритма
    Решето Эратосфена

    Конечная версия.

    Основная проблема - алгоритм работает на заданном множисте. А его мы не имеем,
    нет правой границы диапазона. Значит придется иетрировать.

    iter - порядковый номер простого числа, которое требуется найти (входной параметр)
    """
    time1 = time.process_time()
    mem1 = memory_profiler.memory_usage()
    # мы не знаем, сколько простых чисел в каком диапазоне,
    # но можем оценить. Половина четных чисел отпадает сразу, втрое простое число - 3. В сотне его
    # 33 штуки, за минусом половины четным грубо имеем 15. То, есть 65 чисел из 100 точно
    # не простые. Чуть меньше третьей части. Возьмем коэффициент 2, итерация все равно придет к
    # нужному числу. Плюс придется делать меньше лишних обнулений правой
    # границы.
    if iter1 == 1:
        return 2

    num = iter1 * 2
    # счетчик простых чисел
    count = 0
    # счетчик чисел диапазона
    i = 0
    # ряд натуральных чисел до заданного
    my_list = list(range(1, num + 1, 2))
    # без этой строки итоговый список будет содержать единицу
    my_list[0] = 0
    # будем итерерировать пока не найдем заданное число
    while True:
        # переходим к следующему числу
        i += 1
        # if i > 1000: return
        # для 1 значение уже ввели
        if i > 0:
            # если достигли границы диапазона, но нужное число не нашли
            # print(i, (num-1)/2)
            if i > (num / 2 - 1):
                # обнуляем счетчик ряда
                i = 0
                # расширяем диапазон поиска в два раза
                num *= 2
                # заново формируем массив чисел
                my_list = list(range(1, num + 1, 2))
                my_list[0] = 0
                # обнуляем счетчик простых чисел
                count = 0
                # переходим на следующую итерацию цикла с новыми значениями
                continue
            # 1. Улучшение. Если значение этого элемента нашего массива равно нулю,
            # значит оно было кратно одному из предыдущих членов массива и уже обнулилось.
            # Поэтому и все остальные элементы кратные это му числу уже заведомо обнулены.
            # Прерываемся и перходим к следующему
            if my_list[i] == 0:
                continue
            # Вот тут важный момент! В этой области могут быть уже только простые числа i.
            # Сложные уже отсеялись на прошлом шаге и обнулены. Тут мы имеем дело с очередным
            # простым числом и будем удалять вправо кратные ему числа. Слева от него или нули, или
            # простые. Поэтому увеличиваем счетчик простых чисел
            count += 1
            # если нужное нам число, возвращаем его и выходим
            if count == iter1 - 1:
                time2 = time.process_time()
                mem2 = memory_profiler.memory_usage()
                time_diff = time2 - time1
                mem_diff = mem2[0] - mem1[0]
                print(f"Выполнение заняло {time_diff} сек и {mem_diff} Мб")
                return 2 * i + 1
            # если до нужного еще не дошли, то убираем заведомо составные числа из правого
            # края массива. Идем по ряду с шагом i (кратным нашему числу),
            # тем самым обнуляя все элементы, кратные i.
            #
            # 2. улучшение - начинаем с элемента i в квадрате,
            # так как идем по возрастанию и остальные элементы обнулены от
            # предыдущих чисел.

            for j in range(2 * i * (i + 1), num // 2, 2 * i + 1):
                # print(j,i)
                my_list[j] = 0
                # print(my_list)
# ------------------------------------------------------------------------------------------------

# вперед


# порядковый номер искомого простого числа
I = 1000000
print(f"ert для {I}: {ert(I)}")
