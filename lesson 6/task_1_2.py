"""
1.	Подсчитать, сколько было выделено памяти под переменные в ранее
разработанных программах в рамках первых трех уроков.
Проанализировать результат и определить программы с
наиболее эффективным использованием памяти.
Примечание: Для анализа возьмите любые 1-3 ваших программы или несколько
вариантов кода для одной и той же задачи.
Результаты анализа вставьте в виде комментариев к коду.
Также укажите в комментариях версию Python и разрядность вашей ОС.


ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
"""
# импортируем функцию замера времени работы из первого задания
import time
import memory_profiler
# ------------------------------------------------------------------------------------------------
# 1. Втрой шаг улучшения - алгометрический. Логика алгоритма такова, что если в исходном массиве
# не найдено нужное число, то длина массива увеличивается вдвое и все начинается заново. Но
# первую половину массива мы уже прошли и проходим его заново! Значит можно просто проходить
# вторую половину массива и количество найденных простых чисел прибавлять к количеству найденных
# на предыдущем шаге. В результате, МЫ РАБОТАЕМ С МАССИВОМ ПОСТОЯННОЙ ДЛИНЫ, то есть занимаем
# постоянный объем памяти! Стратегическое решение достигнуто!

# 2. Результаты.
    # Было
    # Выполнение заняло 12.53125 сек и 635.1796875 Мб
    # ert для 1000000: 15485867

    # Вариант 2
    # Выполнение заняло 8.921875 сек и 325.96484375 Мб
    # ert для 1000000: 15485867

    # Вариант 3
    # Выполнение заняло 17.34375 сек и 2.12109375 Мб
    # ert для 1000000: 15485863

    # Итог: число совпало. Памяти в сотни раз меньше и она не зависит от порядкового номера
    # искомого числа. Мы сняли главный недостаток алгоритма решета!!!!!!!! Если заведомо убрать
    # из прогона четные числа, то память уменьшится в два раза, а скорость увеличится в полтора, но
    # но формулы осбсчета слишком громоздкие, код плохо читается.

def ert(iter1):
    """
    Реализация алгоритма
    Решето Эратосфена

    Конечная версия.

    Основная проблема - алгоритм работает на заданном множисте. А его мы не имеем,
    нет правой границы диапазона. Значит придется иетрировать.

    iter - порядковый номер простого числа, которое требуется найти (входной параметр)
    """
    time1 = time.process_time()
    mem1 = memory_profiler.memory_usage()
    # мы не знаем, сколько простых чисел в каком диапазоне,
    # но можем оценить. Половина четных чисел отпадает сразу, втрое простое число - 3. В сотне его
    # 33 штуки, за минусом половины четным грубо имеем 15. То, есть 65 чисел из 100 точно
    # не простые. Чуть меньше третьей части. Возьмем коэффициент 2, итерация все равно придет к
    # нужному числу. Плюс придется делать меньше лишних обнулений правой
    # границы.
    # задаем размер массива, чем он больше, тем больше памяти и возможных лишних операций
    # с другой стороны, если он совсем маленький, то слишком много операций, что замедляет работу
    # возьмем примерный оптимум
    num = 50000
    # ряд натуральных чисел до заданного
    start = 0
    stop = num
    my_list = list(range(start, stop))
    # хранение простых чисел
    prime_numbers = []
    # счетчик простых чисел
    count = 0
    # счетчик чисел диапазона
    i = 0


    # без этой строки итоговый список будет содержать единицу
    my_list[1] = 0
    # будем итерерировать пока не найдем заданное число
    while True:
        # переходим к следующему числу
        i += 1
        # для 1 значение уже ввели
        if i > 1:
            # если достигли границы диапазона, но нужное число не нашли
            if i == num:
                # обнуляем счетчик ряда
                i = 0
                # сохраняем через множество простые числа и убираем 0
                prime_numbers = list(set(my_list))
                prime_numbers.remove(0)
                # увеличиваем счетчик простых чисел
                count += len(prime_numbers)
                # заново формируем массив чисел с новыми границами
                start += num
                stop += num
                my_list = list(range(start, stop))
                # переходим на следующую итерацию цикла с новыми значениями
                continue
            # если счетчик простых чисел больше требуемого, возвращаем его и выходим
            if count > iter1:
                # сортируем последние полученные простые числа, так как множества не сортированы
                prime_numbers.sort()
                # индекс искомого числа в списке
                step = iter1 - count - 1
                # текущие данные данные замеров времени и памяти
                time2 = time.process_time()
                mem2 = memory_profiler.memory_usage()
                time_diff = time2 - time1
                mem_diff = mem2[0] - mem1[0]
                print(f"Выполнение заняло {time_diff} сек и {mem_diff} Мб")
                # возвращаем число
                return prime_numbers[step]
            # промежуточная переменная
            ost = 0
            # 2. улучшение - начинаем с элемента i в квадрате,
            # так как идем по возрастанию и остальные элементы обнулены от
            # предыдущих чисел.
            chc = i ** 2
            # расчет индекса обнудяемого числа в следующем списке
            # вычитаем значение начала обнулиния из начального значения нового списка
            res = chc - start
            # если значения списка дальше от начального, то расчитываем индекс старта
            # вновом списке
            if res < 0:
                # остаток от деления между разницей начального элементом списка и точки начального
                # старта даст нам индекс старта в новом массиве
                ost = (-1) * res % i
                if ost == 0:
                    res = 0
                else:
                    res = i - ost
            # сначала проверим, что точка начала обнуления массива не превышает массив (т.е.
            # квартат обнуляемого числа меньше большего числа массива)
            if res >= num:
                continue
            for j in range(res, num, i):
                #print(f'j = {j}', my_list)
                my_list[j] = 0
            #print(f'i = {i}', my_list)


# ------------------------------------------------------------------------------------------------

# вперед

# порядковый номер искомого простого числа
I = 1000000
print(f"ert для {I}: {ert(I)}")
